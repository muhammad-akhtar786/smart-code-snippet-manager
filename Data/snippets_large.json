{
    "avl tree": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data, height;\n    Node* left;\n    Node* right;\n    Node(int val) : data(val), height(1), left(NULL), right(NULL) {}\n};\n\nint getHeight(Node* node) {\n    return node ? node->height : 0;\n}\n\nint getBalance(Node* node) {\n    return node ? getHeight(node->left) - getHeight(node->right) : 0;\n}\n\nNode* rotateRight(Node* y) {\n    Node* x = y->left;\n    Node* T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = 1 + max(getHeight(y->left), getHeight(y->right));\n    x->height = 1 + max(getHeight(x->left), getHeight(x->right));\n    return x;\n}\n\nNode* insert(Node* node, int val) {\n    if (!node) return new Node(val);\n    if (val < node->data) node->left = insert(node->left, val);\n    else if (val > node->data) node->right = insert(node->right, val);\n    else return node;\n    node->height = 1 + max(getHeight(node->left), getHeight(node->right));\n    int balance = getBalance(node);\n    if (balance > 1 && val < node->left->data) return rotateRight(node);\n    return node;\n}\n\nvoid inorder(Node* root) {\n    if (!root) return;\n    inorder(root->left);\n    cout << root->data << \" \";\n    inorder(root->right);\n}\n\nint main() {\n    Node* root = NULL;\n    int arr[] = {10, 20, 30, 40, 50, 25};\n    for (int val : arr) root = insert(root, val);\n    inorder(root);\n    return 0;\n}",
    "bfs": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nvoid bfs(int start, vector<vector<int>>& adj, int n) {\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout << node << \" \";\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nint main() {\n    int n = 5;\n    vector<vector<int>> adj(n);\n    adj[0] = {1, 2};\n    adj[1] = {0, 3};\n    adj[2] = {0, 4};\n    adj[3] = {1};\n    adj[4] = {2};\n    bfs(0, adj, n);\n    return 0;\n}",
    "binary search": "#include <iostream>\nusing namespace std;\n\nint binarySearch(int arr[], int n, int x) {\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == x) return mid;\n        else if (arr[mid] < x) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {2, 3, 4, 10, 40};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, n, x);\n    if (result != -1) cout << \"Element found at index \" << result;\n    else cout << \"Element not found\";\n    return 0;\n}",
    "binary search tree": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) : data(val), left(NULL), right(NULL) {}\n};\n\nNode* insert(Node* root, int val) {\n    if (root == NULL) return new Node(val);\n    if (val < root->data) root->left = insert(root->left, val);\n    else root->right = insert(root->right, val);\n    return root;\n}\n\nvoid inorder(Node* root) {\n    if (root == NULL) return;\n    inorder(root->left);\n    cout << root->data << \" \";\n    inorder(root->right);\n}\n\nint main() {\n    Node* root = NULL;\n    int arr[] = {50, 30, 70, 20, 40, 60, 80};\n    for (int val : arr) root = insert(root, val);\n    inorder(root);\n    return 0;\n}",
    "bubble sort": "#include<iostream>\nusing namespace std;\n\nint main()\n{\nreturn 0;\n}",
    "combinations": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid combine(int n, int k, int start, vector<int>& current, vector<vector<int>>& result) {\n    if (current.size() == k) {\n        result.push_back(current);\n        return;\n    }\n    for (int i = start; i <= n; i++) {\n        current.push_back(i);\n        combine(n, k, i + 1, current, result);\n        current.pop_back();\n    }\n}\n\nint main() {\n    int n = 4, k = 2;\n    vector<vector<int>> result;\n    vector<int> current;\n    combine(n, k, 1, current, result);\n    for (auto& combo : result) {\n        for (int num : combo) cout << num << \" \";\n        cout << endl;\n    }\n    return 0;\n}",
    "dfs": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {\n    visited[node] = true;\n    cout << node << \" \";\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, adj, visited);\n        }\n    }\n}\n\nint main() {\n    int n = 5;\n    vector<vector<int>> adj(n);\n    adj[0] = {1, 2};\n    adj[1] = {0, 3};\n    adj[2] = {0, 4};\n    adj[3] = {1};\n    adj[4] = {2};\n    vector<bool> visited(n, false);\n    dfs(0, adj, visited);\n    return 0;\n}",
    "edit distance": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint editDistance(string a, string b) {\n    int m = a.length(), n = b.length();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n    for (int i = 0; i <= m; i++) dp[i][0] = i;\n    for (int j = 0; j <= n; j++) dp[0][j] = j;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});\n            }\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    string a = \"horse\";\n    string b = \"ros\";\n    cout << \"Edit distance: \" << editDistance(a, b);\n    return 0;\n}",
    "factorial": "#include <iostream>\nusing namespace std;\n\nint factorial(int n) {\n    if (n == 0 || n == 1) return 1;\n    return n * factorial(n - 1);\n}\n\nint factorialDP(int n) {\n    int dp[n + 1];\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = i * dp[i - 1];\n    }\n    return dp[n];\n}\n\nint main() {\n    int n = 5;\n    cout << \"Factorial (Recursive): \" << factorial(n) << endl;\n    cout << \"Factorial (DP): \" << factorialDP(n) << endl;\n    return 0;\n}",
    "fibonacci": "#include <iostream>\nusing namespace std;\n\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint fibonacciDP(int n) {\n    int dp[n + 1];\n    dp[0] = 0; dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n\nint main() {\n    int n = 10;\n    cout << \"Fibonacci (Recursive): \" << fibonacci(n) << endl;\n    cout << \"Fibonacci (DP): \" << fibonacciDP(n) << endl;\n    return 0;\n}",
    "gcd": "#include <iostream>\nusing namespace std;\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    int a = 48, b = 18;\n    cout << \"GCD of \" << a << \" and \" << b << \" is \" << gcd(a, b);\n    return 0;\n}",
    "hashing": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    unordered_map<int, string> map;\n    map[1] = \"One\";\n    map[2] = \"Two\";\n    map[3] = \"Three\";\n    for (auto& p : map) {\n        cout << p.first << \" : \" << p.second << endl;\n    }\n    return 0;\n}",
    "heap sort": "#include <iostream>\nusing namespace std;\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1, right = 2 * i + 2;\n    if (left < n && arr[left] > arr[largest]) largest = left;\n    if (right < n && arr[right] > arr[largest]) largest = right;\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    heapSort(arr, n);\n    for (int i = 0; i < n; i++) cout << arr[i] << \" \";\n    return 0;\n}",
    "Hello": "#include<iostream>\nusing namsepace std;\n\nint main()\n{\ncout<<\"Hello World\"<<endl;\nreturn 0;\n}",
    "inorder traversal": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) : data(val), left(NULL), right(NULL) {}\n};\n\nvoid inorder(Node* root) {\n    if (root == NULL) return;\n    inorder(root->left);\n    cout << root->data << \" \";\n    inorder(root->right);\n}\n\nint main() {\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    inorder(root);\n    return 0;\n}",
    "insertion sort": "#include <iostream>\nusing namespace std;\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    for (int i = 0; i < n; i++) cout << arr[i] << \" \";\n    return 0;\n}",
    "knapsack 0/1": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint knapsack(int W, vector<int>& weights, vector<int>& values, int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));\n    for (int i = 1; i <= n; i++) {\n        for (int w = 1; w <= W; w++) {\n            if (weights[i - 1] <= w) {\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);\n            } else {\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n    return dp[n][W];\n}\n\nint main() {\n    vector<int> weights = {2, 3, 4, 5};\n    vector<int> values = {3, 4, 5, 6};\n    int W = 8;\n    cout << \"Maximum value: \" << knapsack(W, weights, values, 4);\n    return 0;\n}",
    "longest common subsequence": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint lcs(string a, string b) {\n    int m = a.length(), n = b.length();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    string a = \"AGGTAB\";\n    string b = \"GXTXAYB\";\n    cout << \"LCS length: \" << lcs(a, b);\n    return 0;\n}",
    "merge sort": "#include <iostream>\nusing namespace std;\n\nvoid merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1, n2 = r - m;\n    int L[n1], R[n2];\n    for (int i = 0; i < n1; i++) L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) arr[k++] = L[i++];\n        else arr[k++] = R[j++];\n    }\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    mergeSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) cout << arr[i] << \" \";\n    return 0;\n}",
    "n queens": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isSafe(vector<vector<int>>& board, int row, int col, int n) {\n    for (int i = 0; i < col; i++) if (board[row][i]) return false;\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) if (board[i][j]) return false;\n    for (int i = row, j = col; i < n && j >= 0; i++, j--) if (board[i][j]) return false;\n    return true;\n}\n\nvoid solveNQueens(vector<vector<int>>& board, int col, int n) {\n    if (col == n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) cout << board[i][j] << \" \";\n            cout << endl;\n        }\n        cout << endl;\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 1;\n            solveNQueens(board, col + 1, n);\n            board[row][col] = 0;\n        }\n    }\n}\n\nint main() {\n    int n = 4;\n    vector<vector<int>> board(n, vector<int>(n, 0));\n    solveNQueens(board, 0, n);\n    return 0;\n}",
    "permutations": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid permute(vector<int>& nums, int start) {\n    if (start == nums.size()) {\n        for (int num : nums) cout << num << \" \";\n        cout << endl;\n        return;\n    }\n    for (int i = start; i < nums.size(); i++) {\n        swap(nums[start], nums[i]);\n        permute(nums, start + 1);\n        swap(nums[start], nums[i]);\n    }\n}\n\nint main() {\n    vector<int> nums = {1, 2, 3};\n    permute(nums, 0);\n    return 0;\n}",
    "quick sort": "#include <iostream>\nusing namespace std;\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) swap(arr[++i], arr[j]);\n    }\n    swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) cout << arr[i] << \" \";\n    return 0;\n}",
    "red black tree": "#include <iostream>\nusing namespace std;\n\nenum Color { RED, BLACK };\n\nstruct Node {\n    int data;\n    Node* parent;\n    Node* left;\n    Node* right;\n    Color color;\n    Node(int val) : data(val), parent(NULL), left(NULL), right(NULL), color(RED) {}\n};\n\nvoid insertRBTree(Node*& root, int val) {\n    Node* newNode = new Node(val);\n    if (root == NULL) {\n        newNode->color = BLACK;\n        root = newNode;\n    } else {\n        Node* current = root;\n        while (current != NULL) {\n            if (val < current->data) {\n                if (current->left == NULL) {\n                    current->left = newNode;\n                    newNode->parent = current;\n                    break;\n                } else current = current->left;\n            } else {\n                if (current->right == NULL) {\n                    current->right = newNode;\n                    newNode->parent = current;\n                    break;\n                } else current = current->right;\n            }\n        }\n    }\n}\n\nint main() {\n    Node* root = NULL;\n    int arr[] = {7, 3, 18, 10, 22, 8, 11, 26};\n    for (int val : arr) insertRBTree(root, val);\n    cout << \"Red-Black Tree created successfully\";\n    return 0;\n}",
    "selection sort": "#include <iostream>\nusing namespace std;\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIdx]) minIdx = j;\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    selectionSort(arr, n);\n    for (int i = 0; i < n; i++) cout << arr[i] << \" \";\n    return 0;\n}",
    "test snippet": "public class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}",
    "two sum": "#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& nums, int target) {\n    unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}\n\nint main() {\n    vector<int> nums = {2, 7, 11, 15};\n    int target = 9;\n    vector<int> result = twoSum(nums, target);\n    cout << \"Indices: \" << result[0] << \", \" << result[1];\n    return 0;\n}"
}
