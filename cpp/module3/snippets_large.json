{
  "bubble sort": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid bubbleSort(vector<int>& arr) {\n    int n = arr.size();\n    for(int i = 0; i < n-1; i++)\n        for(int j = 0; j < n-i-1; j++)\n            if(arr[j] > arr[j+1])\n                swap(arr[j], arr[j+1]);\n}",
  "selection sort": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid selectionSort(vector<int>& arr) {\n    int n = arr.size();\n    for(int i = 0; i < n-1; i++) {\n        int minIdx = i;\n        for(int j = i+1; j < n; j++)\n            if(arr[j] < arr[minIdx])\n                minIdx = j;\n        swap(arr[i], arr[minIdx]);\n    }\n}",
  "insertion sort": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid insertionSort(vector<int>& arr) {\n    int n = arr.size();\n    for(int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while(j >= 0 && arr[j] > key) {\n            arr[j+1] = arr[j];\n            j--;\n        }\n        arr[j+1] = key;\n    }\n}",
  "merge sort": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid merge(vector<int>& arr, int l, int m, int r) {\n    int n1 = m - l + 1, n2 = r - m;\n    vector<int> L(n1), R(n2);\n    for(int i = 0; i < n1; i++) L[i] = arr[l+i];\n    for(int i = 0; i < n2; i++) R[i] = arr[m+1+i];\n    int i = 0, j = 0, k = l;\n    while(i < n1 && j < n2)\n        arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];\n    while(i < n1) arr[k++] = L[i++];\n    while(j < n2) arr[k++] = R[j++];\n}\nvoid mergeSort(vector<int>& arr, int l, int r) {\n    if(l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m+1, r);\n        merge(arr, l, m, r);\n    }\n}",
  "quick sort": "#include<iostream>\n#include<vector>\nusing namespace std;\nint partition(vector<int>& arr, int l, int r) {\n    int pivot = arr[r];\n    int i = l - 1;\n    for(int j = l; j < r; j++) {\n        if(arr[j] < pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i+1], arr[r]);\n    return i + 1;\n}\nvoid quickSort(vector<int>& arr, int l, int r) {\n    if(l < r) {\n        int pi = partition(arr, l, r);\n        quickSort(arr, l, pi-1);\n        quickSort(arr, pi+1, r);\n    }\n}",
  "heap sort": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid heapify(vector<int>& arr, int n, int i) {\n    int largest = i;\n    int l = 2*i + 1, r = 2*i + 2;\n    if(l < n && arr[l] > arr[largest]) largest = l;\n    if(r < n && arr[r] > arr[largest]) largest = r;\n    if(largest != i) {\n        swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\nvoid heapSort(vector<int>& arr) {\n    int n = arr.size();\n    for(int i = n/2-1; i >= 0; i--)\n        heapify(arr, n, i);\n    for(int i = n-1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}",
  "counting sort": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvoid countingSort(vector<int>& arr) {\n    int n = arr.size();\n    int maxVal = *max_element(arr.begin(), arr.end());\n    vector<int> count(maxVal + 1, 0);\n    for(int i = 0; i < n; i++) count[arr[i]]++;\n    for(int i = 1; i <= maxVal; i++)\n        count[i] += count[i-1];\n    vector<int> output(n);\n    for(int i = n-1; i >= 0; i--) {\n        output[count[arr[i]]-1] = arr[i];\n        count[arr[i]]--;\n    }\n    for(int i = 0; i < n; i++) arr[i] = output[i];\n}",
  "radix sort": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvoid countSort(vector<int>& arr, int exp) {\n    int n = arr.size();\n    vector<int> output(n);\n    vector<int> count(10, 0);\n    for(int i = 0; i < n; i++)\n        count[(arr[i]/exp)%10]++;\n    for(int i = 1; i < 10; i++)\n        count[i] += count[i-1];\n    for(int i = n-1; i >= 0; i--) {\n        output[count[(arr[i]/exp)%10]-1] = arr[i];\n        count[(arr[i]/exp)%10]--;\n    }\n    for(int i = 0; i < n; i++) arr[i] = output[i];\n}\nvoid radixSort(vector<int>& arr) {\n    int maxVal = *max_element(arr.begin(), arr.end());\n    for(int exp = 1; maxVal/exp > 0; exp *= 10)\n        countSort(arr, exp);\n}",
  "bucket sort": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvoid bucketSort(vector<int>& arr) {\n    int n = arr.size();\n    int maxVal = *max_element(arr.begin(), arr.end());\n    vector<vector<int>> buckets(n);\n    for(int i = 0; i < n; i++)\n        buckets[(arr[i]*n)/(maxVal+1)].push_back(arr[i]);\n    for(int i = 0; i < n; i++)\n        sort(buckets[i].begin(), buckets[i].end());\n    int idx = 0;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < buckets[i].size(); j++)\n            arr[idx++] = buckets[i][j];\n}",
  "shell sort": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid shellSort(vector<int>& arr) {\n    int n = arr.size();\n    for(int gap = n/2; gap > 0; gap /= 2) {\n        for(int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            for(j = i; j >= gap && arr[j-gap] > temp; j -= gap)\n                arr[j] = arr[j-gap];\n            arr[j] = temp;\n        }\n    }\n}",
  "linear search": "#include<iostream>\n#include<vector>\nusing namespace std;\nint linearSearch(vector<int>& arr, int x) {\n    for(int i = 0; i < arr.size(); i++)\n        if(arr[i] == x) return i;\n    return -1;\n}",
  "binary search": "#include<iostream>\n#include<vector>\nusing namespace std;\nint binarySearch(vector<int>& arr, int x) {\n    int l = 0, r = arr.size() - 1;\n    while(l <= r) {\n        int m = l + (r - l) / 2;\n        if(arr[m] == x) return m;\n        if(arr[m] < x) l = m + 1;\n        else r = m - 1;\n    }\n    return -1;\n}",
  "binary search tree": "#include<iostream>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n};\nNode* insert(Node* root, int data) {\n    if(root == NULL) {\n        root = new Node();\n        root->data = data;\n        root->left = root->right = NULL;\n    } else if(data < root->data)\n        root->left = insert(root->left, data);\n    else\n        root->right = insert(root->right, data);\n    return root;\n}",
  "avl tree": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct AVLNode {\n    int data, height;\n    AVLNode* left;\n    AVLNode* right;\n};\nint getHeight(AVLNode* n) { return n == NULL ? 0 : n->height; }\nint getBalance(AVLNode* n) {\n    return n == NULL ? 0 : getHeight(n->left) - getHeight(n->right);\n}\nAVLNode* rotateRight(AVLNode* y) {\n    AVLNode* x = y->left;\n    y->left = x->right;\n    x->right = y;\n    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;\n    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;\n    return x;\n}",
  "red black tree": "#include<iostream>\nusing namespace std;\nstruct RBNode {\n    int data;\n    RBNode* parent;\n    RBNode* left;\n    RBNode* right;\n    bool isRed;\n};\nvoid rotateLeft(RBNode* x) {\n    RBNode* y = x->right;\n    x->right = y->left;\n    if(y->left != NULL) y->left->parent = x;\n    y->parent = x->parent;\n    if(x->parent == NULL) ;\n    else if(x == x->parent->left) x->parent->left = y;\n    else x->parent->right = y;\n    y->left = x;\n    x->parent = y;\n}",
  "b tree": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct BNode {\n    vector<int> keys;\n    vector<BNode*> children;\n    bool isLeaf;\n};\nvoid traverse(BNode* root) {\n    int i = 0;\n    for(i = 0; i < root->keys.size(); i++) {\n        if(!root->isLeaf)\n            traverse(root->children[i]);\n        cout << root->keys[i] << \" \";\n    }\n    if(!root->isLeaf) traverse(root->children[i]);\n}",
  "trie": "#include<iostream>\n#include<unordered_map>\n#include<string>\nusing namespace std;\nstruct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    bool isEndOfWord;\n};\nvoid insert(TrieNode* root, string word) {\n    TrieNode* pCrawl = root;\n    for(char c : word) {\n        if(pCrawl->children.find(c) == pCrawl->children.end())\n            pCrawl->children[c] = new TrieNode();\n        pCrawl = pCrawl->children[c];\n    }\n    pCrawl->isEndOfWord = true;\n}",
  "segment tree": "#include<iostream>\n#include<vector>\nusing namespace std;\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n    void build(vector<int>& arr, int node, int start, int end) {\n        if(start == end) tree[node] = arr[start];\n        else {\n            int mid = (start + end) / 2;\n            build(arr, 2*node, start, mid);\n            build(arr, 2*node+1, mid+1, end);\n            tree[node] = tree[2*node] + tree[2*node+1];\n        }\n    }\npublic:\n    SegmentTree(vector<int>& arr) {\n        n = arr.size();\n        tree.resize(4*n);\n        build(arr, 1, 0, n-1);\n    }\n}",
  "fenwick tree": "#include<iostream>\n#include<vector>\nusing namespace std;\nclass FenwickTree {\n    vector<int> tree;\n    int n;\npublic:\n    FenwickTree(int n) : n(n), tree(n+1, 0) {}\n    void update(int idx, int delta) {\n        for(int i = idx; i <= n; i += i & (-i))\n            tree[i] += delta;\n    }\n    int query(int idx) {\n        int sum = 0;\n        for(int i = idx; i > 0; i -= i & (-i))\n            sum += tree[i];\n        return sum;\n    }\n}",
  "hash table": "#include<iostream>\nusing namespace std;\nconst int MAX = 1000;\nint hash_table[MAX];\nint hashFunction(int key) { return key % MAX; }\nvoid insert(int key) {\n    int index = hashFunction(key);\n    hash_table[index] = key;\n}\nbool search(int key) {\n    int index = hashFunction(key);\n    return hash_table[index] == key;\n}",
  "graph adjacency matrix": "#include<iostream>\nusing namespace std;\nconst int MAX = 100;\nint adj[MAX][MAX];\nvoid addEdge(int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\nbool hasEdge(int u, int v) {\n    return adj[u][v] == 1;\n}",
  "graph adjacency list": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int> adj[100];\nvoid addEdge(int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\nvoid printGraph(int n) {\n    for(int i = 0; i < n; i++) {\n        cout << i << \": \";\n        for(int j : adj[i])\n            cout << j << \" \";\n        cout << endl;\n    }\n}",
  "dfs": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid dfs(int node, vector<int> adj[], vector<bool>& visited) {\n    visited[node] = true;\n    cout << node << \" \";\n    for(int neighbor : adj[node])\n        if(!visited[neighbor])\n            dfs(neighbor, adj, visited);\n}",
  "bfs": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nvoid bfs(int start, vector<int> adj[], int n) {\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    while(!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout << node << \" \";\n        for(int neighbor : adj[node])\n            if(!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n    }\n}",
  "dijkstra": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<climits>\nusing namespace std;\nvoid dijkstra(int src, vector<vector<pair<int,int>>>& graph, int n) {\n    vector<int> dist(n, INT_MAX);\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\n    dist[src] = 0;\n    pq.push({0, src});\n    while(!pq.empty()) {\n        int d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        if(d > dist[u]) continue;\n        for(auto& edge : graph[u]) {\n            int v = edge.first;\n            int w = edge.second;\n            if(dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}",
  "bellman ford": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\nbool bellmanFord(int src, vector<vector<int>>& edges, int n) {\n    vector<int> dist(n, INT_MAX);\n    dist[src] = 0;\n    for(int i = 0; i < n-1; i++)\n        for(auto& e : edges) {\n            int u = e[0], v = e[1], w = e[2];\n            if(dist[u] != INT_MAX && dist[u] + w < dist[v])\n                dist[v] = dist[u] + w;\n        }\n    for(auto& e : edges) {\n        int u = e[0], v = e[1], w = e[2];\n        if(dist[u] != INT_MAX && dist[u] + w < dist[v])\n            return false;\n    }\n    return true;\n}",
  "floyd warshall": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAX = 100;\nvoid floydWarshall(int dist[][MAX], int n) {\n    for(int k = 0; k < n; k++)\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n}",
  "prim algorithm": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<climits>\nusing namespace std;\nvoid prim(vector<vector<pair<int,int>>>& graph, int n) {\n    vector<bool> inMST(n, false);\n    vector<int> key(n, INT_MAX);\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\n    key[0] = 0;\n    pq.push({0, 0});\n    while(!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n        inMST[u] = true;\n        for(auto& edge : graph[u]) {\n            int v = edge.first;\n            int w = edge.second;\n            if(!inMST[v] && w < key[v]) {\n                key[v] = w;\n                pq.push({key[v], v});\n            }\n        }\n    }\n}",
  "kruskal algorithm": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint find(vector<int>& parent, int i) {\n    if(parent[i] == i) return i;\n    return find(parent, parent[i]);\n}\nvoid unionSets(vector<int>& parent, vector<int>& rank, int x, int y) {\n    int px = find(parent, x);\n    int py = find(parent, y);\n    if(rank[px] < rank[py]) parent[px] = py;\n    else if(rank[px] > rank[py]) parent[py] = px;\n    else {\n        parent[py] = px;\n        rank[px]++;\n    }\n}",
  "topological sort": "#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\nvoid topoUtil(int v, vector<int> adj[], vector<bool>& visited, stack<int>& st) {\n    visited[v] = true;\n    for(int u : adj[v])\n        if(!visited[u])\n            topoUtil(u, adj, visited, st);\n    st.push(v);\n}\nvoid topologicalSort(vector<int> adj[], int n) {\n    stack<int> st;\n    vector<bool> visited(n, false);\n    for(int i = 0; i < n; i++)\n        if(!visited[i])\n            topoUtil(i, adj, visited, st);\n    while(!st.empty()) {\n        cout << st.top() << \" \";\n        st.pop();\n    }\n}",
  "knapsack 0/1": "#include<iostream>\n#include<vector>\nusing namespace std;\nint knapsack(int W, vector<int>& wt, vector<int>& val, int n) {\n    vector<vector<int>> dp(n+1, vector<int>(W+1, 0));\n    for(int i = 1; i <= n; i++)\n        for(int w = 1; w <= W; w++)\n            if(wt[i-1] <= w)\n                dp[i][w] = max(val[i-1] + dp[i-1][w-wt[i-1]], dp[i-1][w]);\n    return dp[n][W];\n}",
  "unbounded knapsack": "#include<iostream>\n#include<vector>\nusing namespace std;\nint unboundedKnapsack(int W, vector<int>& wt, vector<int>& val, int n) {\n    vector<int> dp(W+1, 0);\n    for(int i = 0; i < n; i++)\n        for(int w = wt[i]; w <= W; w++)\n            dp[w] = max(dp[w], dp[w-wt[i]] + val[i]);\n    return dp[W];\n}",
  "coin change": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\nusing namespace std;\nint coinChange(vector<int>& coins, int amount) {\n    vector<int> dp(amount+1, INT_MAX);\n    dp[0] = 0;\n    for(int i = 1; i <= amount; i++)\n        for(int coin : coins)\n            if(coin <= i && dp[i-coin] != INT_MAX)\n                dp[i] = min(dp[i], dp[i-coin] + 1);\n    return dp[amount] == INT_MAX ? -1 : dp[amount];\n}",
  "longest common subsequence": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint lcs(string a, string b, int m, int n) {\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\n    for(int i = 1; i <= m; i++)\n        for(int j = 1; j <= n; j++)\n            if(a[i-1] == b[j-1])\n                dp[i][j] = dp[i-1][j-1] + 1;\n            else\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n    return dp[m][n];\n}",
  "longest increasing subsequence": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    for(int i = 1; i < n; i++)\n        for(int j = 0; j < i; j++)\n            if(arr[j] < arr[i])\n                dp[i] = max(dp[i], dp[j] + 1);\n    return *max_element(dp.begin(), dp.end());\n}",
  "edit distance": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint editDistance(string a, string b) {\n    int m = a.length(), n = b.length();\n    vector<vector<int>> dp(m+1, vector<int>(n+1));\n    for(int i = 0; i <= m; i++) dp[i][0] = i;\n    for(int j = 0; j <= n; j++) dp[0][j] = j;\n    for(int i = 1; i <= m; i++)\n        for(int j = 1; j <= n; j++)\n            if(a[i-1] == b[j-1])\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\n    return dp[m][n];\n}",
  "fibonacci": "#include<iostream>\n#include<vector>\nusing namespace std;\nint fib(int n) {\n    if(n <= 1) return n;\n    vector<int> dp(n+1);\n    dp[0] = 0;\n    dp[1] = 1;\n    for(int i = 2; i <= n; i++)\n        dp[i] = dp[i-1] + dp[i-2];\n    return dp[n];\n}",
  "factorial": "#include<iostream>\nusing namespace std;\nint factorial(int n) {\n    if(n <= 1) return 1;\n    return n * factorial(n-1);\n}",
  "gcd": "#include<iostream>\nusing namespace std;\nint gcd(int a, int b) {\n    while(b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}",
  "lcm": "#include<iostream>\nusing namespace std;\nint gcd(int a, int b) {\n    while(b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\nint lcm(int a, int b) {\n    return (a / gcd(a, b)) * b;\n}",
  "prime number": "#include<iostream>\nusing namespace std;\nbool isPrime(int n) {\n    if(n <= 1) return false;\n    if(n <= 3) return true;\n    if(n % 2 == 0 || n % 3 == 0) return false;\n    for(int i = 5; i*i <= n; i += 6)\n        if(n % i == 0 || n % (i+2) == 0) return false;\n    return true;\n}",
  "power": "#include<iostream>\nusing namespace std;\nlong long power(long long x, int n) {\n    long long res = 1;\n    while(n > 0) {\n        if(n & 1) res *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return res;\n}",
  "reverse string": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvoid reverseString(string& s) {\n    reverse(s.begin(), s.end());\n}",
  "palindrome string": "#include<iostream>\n#include<string>\nusing namespace std;\nbool isPalindrome(string s) {\n    int l = 0, r = s.length()-1;\n    while(l < r) {\n        if(s[l] != s[r]) return false;\n        l++; r--;\n    }\n    return true;\n}",
  "valid parentheses": "#include<iostream>\n#include<string>\n#include<stack>\nusing namespace std;\nbool isValid(string s) {\n    stack<char> st;\n    for(char c : s) {\n        if(c == '(' || c == '{' || c == '[')\n            st.push(c);\n        else {\n            if(st.empty()) return false;\n            char top = st.top();\n            st.pop();\n            if((c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '['))\n                return false;\n        }\n    }\n    return st.empty();\n}",
  "two sum": "#include<iostream>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\nvector<int> twoSum(vector<int>& nums, int target) {\n    unordered_map<int, int> m;\n    for(int i = 0; i < nums.size(); i++) {\n        if(m.find(target - nums[i]) != m.end())\n            return {m[target - nums[i]], i};\n        m[nums[i]] = i;\n    }\n    return {};\n}",
  "contains duplicate": "#include<iostream>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\nbool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s(nums.begin(), nums.end());\n    return s.size() != nums.size();\n}",
  "best time buy sell": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX, maxProfit = 0;\n    for(int p : prices) {\n        minPrice = min(minPrice, p);\n        maxProfit = max(maxProfit, p - minPrice);\n    }\n    return maxProfit;\n}",
  "majority element": "#include<iostream>\n#include<vector>\nusing namespace std;\nint majorityElement(vector<int>& nums) {\n    int candidate, count = 0;\n    for(int x : nums) {\n        if(count == 0) candidate = x;\n        count += (x == candidate) ? 1 : -1;\n    }\n    return candidate;\n}",
  "unique paths": "#include<iostream>\n#include<vector>\nusing namespace std;\nint uniquePaths(int m, int n) {\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n    for(int i = 1; i < m; i++)\n        for(int j = 1; j < n; j++)\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n    return dp[m-1][n-1];\n}",
  "house robber": "#include<iostream>\n#include<vector>\nusing namespace std;\nint rob(vector<int>& nums) {\n    int prev1 = 0, prev2 = 0;\n    for(int x : nums) {\n        int temp = prev1;\n        prev1 = max(prev2 + x, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}",
  "rotate array": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvoid rotate(vector<int>& nums, int k) {\n    int n = nums.size();\n    k = k % n;\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}",
  "remove duplicates": "#include<iostream>\n#include<vector>\nusing namespace std;\nint removeDuplicates(vector<int>& nums) {\n    int j = 0;\n    for(int i = 1; i < nums.size(); i++)\n        if(nums[i] != nums[i-1])\n            nums[++j] = nums[i];\n    return j + 1;\n}",
  "move zeroes": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid moveZeroes(vector<int>& nums) {\n    int j = 0;\n    for(int i = 0; i < nums.size(); i++)\n        if(nums[i] != 0)\n            swap(nums[i], nums[j++]);\n}"
}
